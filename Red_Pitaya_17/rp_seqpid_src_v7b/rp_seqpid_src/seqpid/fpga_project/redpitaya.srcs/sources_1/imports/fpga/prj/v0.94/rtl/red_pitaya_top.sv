////////////////////////////////////////////////////////////////////////////////
// Red Pitaya TOP module. It connects external pins and PS part with
// the lock-in+scope+pid module.
// Author: Alexei Ourjoumtsev
////////////////////////////////////////////////////////////////////////////////

/**
 * GENERAL DESCRIPTION:
 *
 * Top module connects PS part with SeqPID application.  
 *
 *                   /-------\      
 *   PS DDR <------> |  PS   |      AXI <-> custom bus
 *   PS MIO <------> |   /   | <------------+
 *   PS CLK -------> |  ARM  |              |
 *                   \-------/              |
 *                                          |
 *            /--------\       /-----\      |
 *   ADC ---> |        | ----> |     |      |
 *            | ANALOG |       | PID | <----+
 *   DAC <--- |        | <-+-- |     |      |
 *            \--------/   |   \-----/      |
 *                         |       ^        |
 *                         |       |        |
 *                         |  /---- --\     |
 *                         -- | SeqGen| <---+ 
 *                            \-------/     |
 *                                          |
 *             /--------\                   |
 *    RX ----> |        |                   |
 *   SATA      | DAISY  | <-----------------+
 *    TX <---- |        | 
 *             \--------/ 
 *               |    |
 *               |    |
 *               (FREE)
 *
 * Inside analog module, ADC data is translated from unsigned neg-slope into
 * two's complement. Similar is done on DAC data.
 *
 * SeqGen generates an analog output sequence (1/channel), which is either sent out to DAC directly or used as a setpoint for the PID
 *
 * Daisy chain connects with other boards with fast serial link. Data which is
 * send and received is at the moment undefined. This is left for the user.
 */

module red_pitaya_top #(
  // identification
  bit [0:5*32-1] GITH = '0,
  // module numbers
  int unsigned MNA = 2,  // number of acquisition modules
  int unsigned MNG = 2   // number of generator   modules
)(
  // PS connections
  inout  logic [54-1:0] FIXED_IO_mio     ,
  inout  logic          FIXED_IO_ps_clk  ,
  inout  logic          FIXED_IO_ps_porb ,
  inout  logic          FIXED_IO_ps_srstb,
  inout  logic          FIXED_IO_ddr_vrn ,
  inout  logic          FIXED_IO_ddr_vrp ,
  // DDR
  inout  logic [15-1:0] DDR_addr   ,
  inout  logic [ 3-1:0] DDR_ba     ,
  inout  logic          DDR_cas_n  ,
  inout  logic          DDR_ck_n   ,
  inout  logic          DDR_ck_p   ,
  inout  logic          DDR_cke    ,
  inout  logic          DDR_cs_n   ,
  inout  logic [ 4-1:0] DDR_dm     ,
  inout  logic [32-1:0] DDR_dq     ,
  inout  logic [ 4-1:0] DDR_dqs_n  ,
  inout  logic [ 4-1:0] DDR_dqs_p  ,
  inout  logic          DDR_odt    ,
  inout  logic          DDR_ras_n  ,
  inout  logic          DDR_reset_n,
  inout  logic          DDR_we_n   ,

  // Red Pitaya periphery

  // ADC
  input  logic [MNA-1:0] [16-1:0] adc_dat_i,  // ADC data
  input  logic           [ 2-1:0] adc_clk_i,  // ADC clock {p,n}
  output logic           [ 2-1:0] adc_clk_o,  // optional ADC clock source (unused)
  output logic                    adc_cdcs_o, // ADC clock duty cycle stabilizer
  // DAC
  output logic [14-1:0] dac_dat_o  ,  // DAC combined data
  output logic          dac_wrt_o  ,  // DAC write
  output logic          dac_sel_o  ,  // DAC channel select
  output logic          dac_clk_o  ,  // DAC clock
  output logic          dac_rst_o  ,  // DAC reset
  // Expansion connector
//  inout  logic [ 8-1:0] exp_p_io   ,
//  inout  logic [ 8-1:0] exp_n_io   ,
  output logic [ 4-1:0] exp_n_io   ,
  input  logic          exp_p_io0   ,
  input  logic          exp_p_io1   ,
  output logic          exp_p_io2  ,
  output logic          exp_p_io3  ,
  // SATA connector
//  output logic [ 2-1:0] daisy_p_o  ,  // line 1 is clock capable
//  output logic [ 2-1:0] daisy_n_o  ,
//  input  logic [ 2-1:0] daisy_p_i  ,  // line 1 is clock capable
//  input  logic [ 2-1:0] daisy_n_i  ,
  // LED
  output  logic led_o0
);

////////////////////////////////////////////////////////////////////////////////
// local signals
////////////////////////////////////////////////////////////////////////////////

// GPIO parameter
//localparam int unsigned GDW = 8+8; //Alexei: was unused

logic [4-1:0] fclk ; //[0]-125MHz, [1]-250MHz, [2]-50MHz, [3]-200MHz, always present (generated by PS from 33MHz on-board crystal)
logic [4-1:0] frstn;

// AXI masters
logic            axi1_clk    , axi0_clk    ;
logic            axi1_rstn   , axi0_rstn   ;
logic [ 32-1: 0] axi1_waddr  , axi0_waddr  ;
logic [ 64-1: 0] axi1_wdata  , axi0_wdata  ;
logic [  8-1: 0] axi1_wsel   , axi0_wsel   ;
logic            axi1_wvalid , axi0_wvalid ;
logic [  4-1: 0] axi1_wlen   , axi0_wlen   ;
logic            axi1_wfixed , axi0_wfixed ;
logic            axi1_werr   , axi0_werr   ;
logic            axi1_wrdy   , axi0_wrdy   ;

//ADC clock generation (goes to adc_clk_o driving the ADC)
logic   ext_clk_in;
logic   int_clk_buf;//wiring buffer used for BUFH (if none, Place error 30-120)
logic   clk_ext_use;
logic   clk_ext_use_buf;
logic   adc_clk_o_src;
logic   clk_src_on;

// The ADC sends the clock back as adc_clk_i[1:0], which is used to derive logic clocks and DAC clocks:
logic   adc_clk;
logic   adc_rstn;
logic   pll_locked;


// stream bus type
localparam type SBA_T = logic signed [14-1:0];  // acquire
localparam type SBG_T = logic signed [14-1:0];  // generate

SBA_T [MNA-1:0]          adc_dat;

// DAC signals
logic                    dac_clk_1x;
logic                    dac_clk_2x;
logic                    dac_clk_2p;
logic                    dac_rst;


logic        [14-1:0] dac_dat_a, dac_dat_b;

// SeqPID instrument
logic           soft_trig;
logic           stop_seq;
logic           init_seq_edge;
logic           trig_out_enab;
logic   [2:0]   trig_buf;
logic           rst_reg;
logic           trig_edge;

// SeqPID channels
logic signed [1:0] [14-1:0] seqpid_out;


// system bus
sys_bus_if   ps_sys      (.clk (adc_clk), .rstn (adc_rstn));
sys_bus_if   sys [8-1:0] (.clk (adc_clk), .rstn (adc_rstn));

// GPIO interface //Alexei: cannot be removed
gpio_if #(.DW (24)) gpio ();

////////////////////////////////////////////////////////////////////////////////
// Clock management
////////////////////////////////////////////////////////////////////////////////

/*Alexei:
- We disconnect the 125MHz on-board crystal from the ADC by removing R25 and R26 on the RP,
- We put 0R resistors on R27 and R28 to drive the ADC clock from the FPGA.
- The FPGA always has a (bad) 125MHz clock fclk[0] derived from the 33MHz PS clock crystal
- If the 125MHz ext_clk_in is present, we send it to the ADC, otherwise we send fclk[0]
- We then get the same ("stabilized") clock adc_clk_i from the ADC to generate the other clocks
*/

// tie N bank to ground to reduce cross-talk between P channels
generate
for (genvar i=0; i<4; i++) begin: for_gndN
    OBUF GndN(.O(exp_n_io[i]), .I(1'b0));
end: for_gndN
endgenerate


// External 125MHz clock buffer
//IBUFG i_clk_ext (.I (exp_p_io1), .O (ext_clk_in));  // single-ended clock input
BUFH i_clk_ext (.I (exp_p_io1), .O (ext_clk_in));  // single-ended clock input
//IBUFGDS i_clk_ext (.I (daisy_p_i[1]), .IB (daisy_n_i[1]), .O (ext_clk_in));  // differential clock input
BUFH bufh_intclk (.I(fclk[0]), .O(int_clk_buf)); //required to suppress place error 30-120

 // detect when the external clock is here
extclkdetect ext_clk_detect (
    .clkint(int_clk_buf),
    .clkext(ext_clk_in),
    .clkext_use(clk_ext_use)
    );

always @(posedge int_clk_buf) begin
clk_ext_use_buf <= clk_ext_use;
end

OBUF led_ext_clk(.O(led_o0), .I(clk_ext_use_buf));

//When the external clock is here, it should be used instead of the internal one
BUFGMUX #(.CLK_SEL_TYPE("ASYNC")) adc_clk_out_mux(
.O(adc_clk_o_src),
.I0(int_clk_buf),
.I1(ext_clk_in),
.S(clk_ext_use_buf)
);

//The selected clock generates a differential clock sent to the ADC
ODDR oddr_adc_clk_p ( .Q(adc_clk_o[0]), .D1(1'b1), .D2(1'b0), .C(adc_clk_o_src), .CE(1'b1), .R(1'b0), .S(1'b0));
ODDR oddr_adc_clk_n ( .Q(adc_clk_o[1]), .D1(1'b0), .D2(1'b1), .C(adc_clk_o_src), .CE(1'b1), .R(1'b0), .S(1'b0));
assign adc_cdcs_o = 1'b1 ;// ADC clock duty cycle stabilizer is enabled

// the ADC sends back the differential clock, used by the PLL to generate interal FPGA clock and  clocks driving the DAC

red_pitaya_pll_mod pll (
   // output clocks
   .clk_adc     (adc_clk   ),  // ADC clock
   .clk_dac_1x  (dac_clk_1x),  // DAC clock 125MHz
   .clk_dac_2x  (dac_clk_2x),  // DAC clock 250MHz
   .clk_dac_2p  (dac_clk_2p),  // DAC clock 250MHz -45DGR
   // status outputs
   .resetn      (frstn[0]),  // reset - active low
   .locked      (pll_locked),
   // inputs
   .clk_in1_p    (adc_clk_i[1]),
   .clk_in1_n    (adc_clk_i[0])
 );
 
//Finally, forward the external clock to be used by another device
ODDR oddr_clk_src_out ( .Q(exp_p_io3), .D1(1'b1), .D2(1'b0), .C(ext_clk_in), .CE(clk_src_on), .R(1'b0), .S(1'b0)); //single-ended
//ODDR oddr_clk_src_out_p ( .Q(daisy_p_o[1]), .D1(1'b1), .D2(1'b0), .C(clk_src_out), .CE(1'b1), .R(1'b0), .S(1'b0)); //differential
//ODDR oddr_clk_src_out_n ( .Q(daisy_n_o[1]), .D1(1'b0), .D2(1'b1), .C(clk_src_out), .CE(1'b1), .R(1'b0), .S(1'b0));
 

always @(posedge adc_clk)
adc_rstn <=  frstn[0] &  pll_locked; // ADC reset (active low)


// DAC reset (active high)

always @(posedge dac_clk_1x) begin
dac_rst  <= ~frstn[0] | ~pll_locked;
end

////////////////////////////////////////////////////////////////////////////////
//  Connections to PS
////////////////////////////////////////////////////////////////////////////////

red_pitaya_ps ps (
  .FIXED_IO_mio       (  FIXED_IO_mio                ),
  .FIXED_IO_ps_clk    (  FIXED_IO_ps_clk             ),
  .FIXED_IO_ps_porb   (  FIXED_IO_ps_porb            ),
  .FIXED_IO_ps_srstb  (  FIXED_IO_ps_srstb           ),
  .FIXED_IO_ddr_vrn   (  FIXED_IO_ddr_vrn            ),
  .FIXED_IO_ddr_vrp   (  FIXED_IO_ddr_vrp            ),
  // DDR
  .DDR_addr      (DDR_addr    ),
  .DDR_ba        (DDR_ba      ),
  .DDR_cas_n     (DDR_cas_n   ),
  .DDR_ck_n      (DDR_ck_n    ),
  .DDR_ck_p      (DDR_ck_p    ),
  .DDR_cke       (DDR_cke     ),
  .DDR_cs_n      (DDR_cs_n    ),
  .DDR_dm        (DDR_dm      ),
  .DDR_dq        (DDR_dq      ),
  .DDR_dqs_n     (DDR_dqs_n   ),
  .DDR_dqs_p     (DDR_dqs_p   ),
  .DDR_odt       (DDR_odt     ),
  .DDR_ras_n     (DDR_ras_n   ),
  .DDR_reset_n   (DDR_reset_n ),
  .DDR_we_n      (DDR_we_n    ),
  // system signals
  .fclk_clk_o    (fclk        ),
  .fclk_rstn_o   (frstn       ),
  // ADC analog inputs
  .vinp_i        (5'b0 /*vinp_i*/      ), //Alexei: disabled
  .vinn_i        (5'b0 /*vinn_i*/      ),//Alexei: disabled
  // GPIO //Alexei:unused
  .gpio          (gpio),
  // system read/write channel
  .bus           (ps_sys      ),
  // AXI masters
  .axi1_clk_i    (axi1_clk    ),  .axi0_clk_i    (axi0_clk    ),  // global clock
  .axi1_rstn_i   (axi1_rstn   ),  .axi0_rstn_i   (axi0_rstn   ),  // global reset
  .axi1_waddr_i  (axi1_waddr  ),  .axi0_waddr_i  (axi0_waddr  ),  // system write address
  .axi1_wdata_i  (axi1_wdata  ),  .axi0_wdata_i  (axi0_wdata  ),  // system write data
  .axi1_wsel_i   (axi1_wsel   ),  .axi0_wsel_i   (axi0_wsel   ),  // system write byte select
  .axi1_wvalid_i (axi1_wvalid ),  .axi0_wvalid_i (axi0_wvalid ),  // system write data valid
  .axi1_wlen_i   (axi1_wlen   ),  .axi0_wlen_i   (axi0_wlen   ),  // system write burst length
  .axi1_wfixed_i (axi1_wfixed ),  .axi0_wfixed_i (axi0_wfixed ),  // system write burst type (fixed / incremental)
  .axi1_werr_o   (axi1_werr   ),  .axi0_werr_o   (axi0_werr   ),  // system write error
  .axi1_wrdy_o   (axi1_wrdy   ),  .axi0_wrdy_o   (axi0_wrdy   )   // system write ready
);

////////////////////////////////////////////////////////////////////////////////
// system bus decoder & multiplexer (it breaks memory addresses into 8 regions)
////////////////////////////////////////////////////////////////////////////////

sys_bus_interconnect #(
  .SN (8),
  .SW (20)
) sys_bus_interconnect (
  .bus_m (ps_sys),
  .bus_s (sys)
);

// silence unused busses : bus 1 used for SeqPID instrument, busses 2 & 3 used for SeqPID channels, others silenced

generate
for (genvar i=0; i<1; i++) begin: for_sys_A
  sys_bus_stub sys_bus_stub_0_0 (sys[i]);
end: for_sys_A
endgenerate

generate
for (genvar i=4; i<8; i++) begin: for_sys_B
  sys_bus_stub sys_bus_stub_4_7 (sys[i]);
end: for_sys_B
endgenerate


logic [2-1:0] [14-1:0] adc_dat_raw;

// IO block registers should be used here
// lowest 2 bits reserved for 16bit ADC
always @(posedge adc_clk)
begin
  adc_dat_raw[0] <= adc_dat_i[0][16-1:2];
  adc_dat_raw[1] <= adc_dat_i[1][16-1:2];
end
// transform into 2's complement (negative slope) [Alexei: better timing than doing this on adc_dat_i]    
assign adc_dat[0] = {adc_dat_raw[0][14-1], ~adc_dat_raw[0][14-2:0]};
assign adc_dat[1] = {adc_dat_raw[1][14-1], ~adc_dat_raw[1][14-2:0]};

////////////////////////////////////////////////////////////////////////////////
// DAC IO
////////////////////////////////////////////////////////////////////////////////

// output registers + signed to unsigned (also to negative slope)

always @(posedge dac_clk_1x)
begin
  dac_dat_a <= {seqpid_out[0][14-1], ~seqpid_out[0][14-2:0]};
  dac_dat_b <= {seqpid_out[1][14-1], ~seqpid_out[1][14-2:0]};
end


// DDR outputs
ODDR oddr_dac_clk          (.Q(dac_clk_o), .D1(1'b0     ), .D2(1'b1     ), .C(dac_clk_2p), .CE(1'b1), .R(1'b0   ), .S(1'b0));
ODDR oddr_dac_wrt          (.Q(dac_wrt_o), .D1(1'b0     ), .D2(1'b1     ), .C(dac_clk_2x), .CE(1'b1), .R(1'b0   ), .S(1'b0));
ODDR oddr_dac_sel          (.Q(dac_sel_o), .D1(1'b1     ), .D2(1'b0     ), .C(dac_clk_1x), .CE(1'b1), .R(1'b0   ), .S(1'b0));
ODDR oddr_dac_rst          (.Q(dac_rst_o), .D1(dac_rst  ), .D2(dac_rst  ), .C(dac_clk_1x), .CE(1'b1), .R(1'b0   ), .S(1'b0));
ODDR oddr_dac_dat [14-1:0] (.Q(dac_dat_o), .D1(dac_dat_b), .D2(dac_dat_a), .C(dac_clk_1x), .CE(1'b1), .R(1'b0   ), .S(1'b0));


////////////////////////////////////////////////////////////////////////////////
//  SeqPID instrument module
////////////////////////////////////////////////////////////////////////////////
always @(posedge adc_clk)
    rst_reg <= !adc_rstn;

seqpid_instr i_seqpid_instr(
    .clk(adc_clk),
    .rst(rst_reg),
    .clk_ext_use(clk_ext_use_buf),
    .start_seq(soft_trig),
    .init_seq_edge(init_seq_edge),
    .stop_seq(stop_seq),
    .clk_out_enab(clk_src_on),
    .trig_out_enab(trig_out_enab),
    .sys_addr(sys[1].addr),  //!< bus address, 20 bits per module, see https://redpitaya.readthedocs.io/en/latest/developerGuide/fpga.html
    .sys_wdata(sys[1].wdata),  //!< bus write data
    .sys_wen(sys[1].wen),  //!< bus write enable
    .sys_ren(sys[1].ren),  //!< bus read enable
    .sys_rdata(sys[1].rdata),  //!< bus read data
    .sys_err(sys[1].err),  //!< bus error indicator
    .sys_ack(sys[1].ack)//!< bus acknowledge signal
    );


////////////////////////////////////////////////////////////////////////////////
//  SeqPID channel modules
////////////////////////////////////////////////////////////////////////////////

always @(posedge adc_clk) begin
    trig_buf <= {trig_buf[1],(trig_buf[0] || soft_trig) ,exp_p_io0};
    trig_edge <= trig_buf[1] && (!trig_buf[2]);//at trigger rising edge, goes up for 1 clock cycle
end
OBUF trig_out(.I(trig_buf[1] && trig_out_enab),.O(exp_p_io2));

seqpid_ch i_seqpid_ch [1:0](
  .clk({adc_clk, adc_clk}),
  .rst({rst_reg, rst_reg}),
  // input
  .in({ adc_dat[1],  adc_dat[0] }),
  .trigger( {trig_edge, trig_edge}  ),
  .init_seq(init_seq_edge),
  .stop_seq(stop_seq),
  .out({seqpid_out[1],seqpid_out[0]}),
  // System bus
  .sys_addr      ({sys[3].addr,     sys[2].addr} ),
  .sys_wdata     ({sys[3].wdata,    sys[2].wdata}),
  .sys_wen       ({sys[3].wen,      sys[2].wen}),
  .sys_ren       ({sys[3].ren,      sys[2].ren}),
  .sys_rdata     ({sys[3].rdata,    sys[2].rdata}),
  .sys_err       ({sys[3].err,      sys[2].err}),
  .sys_ack       ({sys[3].ack,      sys[2].ack})
);

endmodule: red_pitaya_top
